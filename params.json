{"name":"Chronicle-wire","tagline":"","body":"Wire Format abstraction library\r\n===\r\n\r\n# Purpose\r\n\r\nChronicle Wire supports a separation of describing what data you want to store and retrieve\r\n   and how it should be rendered/parsed.\r\n   Wire handles a variety of formatting options for a wide range of formats.\r\n\r\nA key aim of Wire is to support schema changes.  It should make reasonable \r\n    attempts to handle\r\n* optional fields\r\n* fields in a different order.\r\n* fields the consumer doesn't expect. Optionally parsing them or ignoring them.\r\n* more or less data than expected (in field-less formats) \r\n* reading a different type to the one written\r\n\r\nIt should also be as efficient as possible in the case where any or all of these are true\r\n* fields are in the order expected.\r\n* fields are the type expected.\r\n* fields names/numbers are not used.\r\n* self describing types are not needed.\r\n* random access of data values is supported.\r\n\r\nWire is designed to make it easy to convert from one wire format to another. \r\n  e.g. you can use fixed width binary data in memory for performance and variable width or text over the network.\r\n  Different TCP connection could use different formats.\r\n  \r\nWire also support hybrid wire formats.  e.g. you can have one format embedded in another.\r\n\r\n# Support\r\nThis library will require Java 8. Support for C++ and C\\# planned.\r\n\r\n# Text Formats\r\n\r\nThe text formats include\r\n* YAML (a subset of mapping structures included)\r\n* JSON (planned)\r\n* XML (planned)\r\n* FIX (proposed)\r\n\r\nOptions include\r\n* field names (e.g. JSON) or field numbers (e.g. FIX)\r\n* optional fields with a default values can be dropped.\r\n* zero copy access to fields. (planned)\r\n* thread safe operations in text. (planned)\r\n\r\nTo support wire format discovery, the first byte should be in the ASCII range,\r\n    adding an ASCII whitespace if needed.\r\n    \r\n# Binary Formats\r\n\r\nThe binary formats include\r\n* Binary YAML\r\n* typed data without fields.\r\n* raw untyped fieldless data\r\n* BSON (Binary JSon) (planned)\r\n\r\nOptions for Binary format\r\n* field names or field numbers\r\n* variable width\r\n* optional fields with a default value can be dropped.\r\n* fixed width data with zero copy support.\r\n* thread safe operations.\r\n\r\nNote: Wire supports debug/transparent combinations like self describing data with zero copy support.\r\n\r\nTo support wire format discovery, the first bytes should have the top bit set.\r\n\r\n# Compression Options\r\n\r\n* no compression\r\n* Snappy compression (planned)\r\n* LZW compression (planned)\r\n\r\n# Bytes options\r\n\r\nWire is built on top of the Bytes library, however Bytes in turn can wrap\r\n\r\n* ByteBuffer - heap and direct\r\n* byte\\[\\] (via ByteBuffer)\r\n* raw memory addresses.\r\n\r\n# Uses\r\n\r\nWire will be used for\r\n\r\n* file headers\r\n* TCP connection headers where the optimal Wire format actually used can be negotiated.\r\n* message/excerpt contents.\r\n* the next version of Chronicle Queue\r\n* the API for marshalling generated data types.\r\n\r\n# Similar projects\r\n\r\n## SBE\r\n\r\nSimple Binary Encoding is designed to do what it says.\r\n    It's simple, it's binary and it supports C++ and Java.  It is \r\n    designed to be more efficient replacement for FIX. It is not limited to FIX \r\n    protocols and can be easily extended by updating an XML schema.\r\n    \r\nXML when it first started didn't use XML for it's own schema files, and it not\r\n   insignificant that SBE doesn't use SBE for it's schema either.  This is because it is\r\n   not trying to be human readable, it has XML which though standard isn't designed\r\n   to be particularly human readable either.  Peter Lawrey thinks it's a limitation that it doesn't\r\n   naturally lend itself to a human readable form.\r\n   \r\nThe encoding SBE uses is similar to binary with field numbers and fixed width types.  \r\n   SBE assumes the field types which can be more compact than Wire's most similar option \r\n   (though not as compact as others)\r\n   \r\nSBE has support for schema changes provided the type of a field doesn't change.\r\n   \r\n## msgpack\r\n\r\nMessage Pack is a packed binary wire format which also supports JSON for \r\n    human readability and compatibility. It has many similarities to the binary \r\n    (and JSON) formats of this library.  c.f. Wire is designed to be human readable first, \r\n    based on YAML, and has a range of options to make it more efficient, \r\n    the most extreme being fixed position binary.\r\n    \r\n Msgpack has support for embedded binary, whereas Wire has support for\r\n    comments and hints to improve rendering for human consumption.\r\n    \r\nThe documentation looks well thought out, and it is worth emulating.\r\n\r\n## Comparison with Cap'n'Proto\r\n\r\n\r\n| Feature\t| Wire Text | Wire Binary | Protobuf\t| Cap'n Proto |\tSBE\t| FlatBuffers |\r\n|------------|:-----------:|:---------------:|:-----------:|:---------------:|:------:|:---------------:|\r\n| Schema evolution |\tyes | yes | yes | \tyes\t| caveats |\tyes |\r\n| Zero-copy | planned | yes | no\t| yes\t | yes\t | yes |\r\n|Random-access reads | \tplanned | yes | no\t | yes\t | no | \tyes |\r\n|Random-access writes | \tplanned | yes | no\t | ?\t | no | \t? |\r\n|Safe against malicious input\t| \tyes | yes\t| yes\t\t| yes\t\t| yes\t\t| opt-in \t| upfront |\r\n|Reflection / generic algorithms\t| \tyes | yes\t| yes\t\t| yes\t\t| yes\t\t| yes |\r\n|Initialization order\t| any | any\t| any\t| \tany\t\t| preorder\t\t| bottom-up |\r\n|Unknown field retention\t| \tyes |  yes\t| yes\t\t| yes\t\t| no\t\t| no |\r\n|Object-capability RPC system\t| \tyes | yes\t| no\t\t| yes\t\t| no\t\t| no |\r\n|Schema language\t| no | no\t| custom\t\t| custom\t\t| XML\t\t| custom |\r\n|Usable as mutable state\t| \tyes | yes\t| yes\t| \tno\t\t| no\t\t| no |\r\n|Padding takes space on wire?\t| \toptional | optional | no\t\t| optional\t| \tyes\t\t| yes |\r\n|Unset fields take space on wire? | optional | optional\t | no\t\t| yes\t\t| yes\t\t| no |\r\n|Pointers take space on wire? | no | no\t\t| no\t\t| yes\t\t| no\t\t| yes |\r\n|C++\t| planned | planned\t| yes\t| \tyes (C++11)*\t\t| yes\t\t| yes |\r\n|Java\t | Java 8 | Java 8\t| yes\t| \tyes*\t\t| yes\t\t| yes |\r\n|C\\#\t | planned | planned\t| yes\t| \tyes*\t| \tyes\t\t| yes* |\r\n|Go | no | no\t\t| yes\t| \tyes\t\t| no\t\t| yes* |\r\n|Other languages\tlots!\t | no | no | 6+ \t| others*\t\t| no\t\t| no |\r\n|Authors' preferred use case|\tdistributed  computing | financial / trading\t| distributed  computing |\tplatforms /  sandboxing\t| financial / trading\t| games |\r\n\r\nBased on https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html\r\n\r\nNote: It not clear what padding which doesn't take up space on the wire means.\r\n\r\n# Design notes\r\n\r\nSee https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html for a comparison to other encoders.\r\n\r\n## Schema evolution.\r\n\r\nWire optionally supports;\r\n- field name changes\r\n- field order changes.\r\n- capturing or ignoring unexpected fields.\r\n- setting of fields to the default if not available.\r\n- raw messages can be longer or short than expected.\r\n\r\nThe more flexibility, the large the overhead in term of CPU and memory.  \r\nWIre allows you to dynamically pick the optimal configuration and convert between these options.\r\n\r\n## Zero copy\r\nWire supports zero copy random access to fields and direct copy from in memory to the network.\r\nIt also support translation from one wire format to another e.g. switching between fixed length data and variable length data.\r\n\r\n\r\n## Random Access.\r\nYou can access a random field in memory\r\n   e.g. in 2 TB file, page in/pull into CPU cache, only the data relating to you read or write.\r\n   \r\n| format | access style |\r\n|----------|------------------|\r\n| fixed length binary | random access without parsing first |\r\n| variable length binary | random access with partial parsing. i.e. you can skip large portions |\r\n| fixed length text | random access with parsing |\r\n| variable length text | no random access |\r\n\r\nWire References are relative to the start of the data contained to allow loading in an arbitrary point in memory.\r\n\r\n## Safe against malicious input\r\nWire has built in tiers of bounds checks to prevent accidental read/writing corrupting the data. \r\n   It is not complete enough for a security review.\r\n   \r\n## Reflection / generic algorithms\r\nWire support generic reading and writing of an arbitrary stream. This can be used in combination with predetermined fields.\r\n   e.g. you can read the fields you know about and asked it to provide the fields you didn't.\r\n   You can also give generic field names like keys to a map as YAML does.\r\n\r\n##  Initialization order\r\n Wire can handle unknown information like lengths by using padding.  \r\n    It will go back and fill in any data which it wasn't aware of as it was writing the data.\r\n    e.g. when it writes an object it doesn't know how long it is going to be so it add padding at the start.  \r\n    Once the object has been written it goes back and overwrites the length. \r\n    It can also hand cases where the length was more than needed known as packing.\r\n\r\n## Unknown field retention?\r\nWire can handle reading data it didn't expect interspersed with data it did expect. \r\n   Rather than specify the expected field name, a StringBuilder is provided.\r\n\r\nNote: there are times when you want to skip/copy an entire field or message without reading any more of it.  This is also supported.\r\n\r\n## Object-maximumLimit RPC system.\r\nWire supports references based on a name, number or UUID.  \r\n   This is useful when including a reference to an object the reader should lookup via another means.\r\n   \r\nA common case if when you have a proxy to a remote object and you want to pass or return this in an RPC call.\r\n\r\n## Schema language\r\nWire's schema is not externalised from the code, however it is planned to use YAML in a format it can parse.\r\n\r\n## Usable as mutable state\r\nWire supports storing an applications internal state. \r\n    This will not allow it to grow or shrink. You can't free any of it without copying \r\n    the pieces you need and discarding the original copy.\r\n    \r\n## Padding takes space on the wire.\r\nThe Wire format chosen determines if there is any padding on the wire. \r\n    If you copy the in memory data directly it's format doesn't change. \r\n    If you want to drop padding you can copy the message to a wire format without padding.\r\n    You can decide whether the original padding is to be preserved or not if turned back into a format with padding.\r\n\r\nWe could look at supporting Cap'n'Proto's zero byte removal compression.\r\n\r\n## Unset fields take space on the wire?\r\nWire supports fields with and without optional fields and automatic means of removing them.  \r\n    It doesn't support automatically adding them back in as information has been lost.\r\n\r\n## Pointers take space on the wire.\r\nWire doesn't have pointer but it does have content lengths which are \r\n   a useful hint for random access and robustness, but these are optional.\r\n\r\n##  Platform support\r\nWire is Java 8 only for now.  Future version may support Java 6, C++ and C\\#\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}