<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Chronicle-wire : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Chronicle-wire</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/OpenHFT/Chronicle-Wire">View on GitHub</a>

          <h1 id="project_title">Chronicle-wire</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/OpenHFT/Chronicle-Wire/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/OpenHFT/Chronicle-Wire/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="wire-format-abstraction-library" class="anchor" href="#wire-format-abstraction-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Wire Format abstraction library</h1>

<h1>
<a id="purpose" class="anchor" href="#purpose" aria-hidden="true"><span class="octicon octicon-link"></span></a>Purpose</h1>

<p>Chronicle Wire supports a separation of describing what data you want to store and retrieve
   and how it should be rendered/parsed.
   Wire handles a variety of formatting options for a wide range of formats.</p>

<p>A key aim of Wire is to support schema changes.  It should make reasonable 
    attempts to handle</p>

<ul>
<li>optional fields</li>
<li>fields in a different order.</li>
<li>fields the consumer doesn't expect. Optionally parsing them or ignoring them.</li>
<li>more or less data than expected (in field-less formats) </li>
<li>reading a different type to the one written</li>
</ul>

<p>It should also be as efficient as possible in the case where any or all of these are true</p>

<ul>
<li>fields are in the order expected.</li>
<li>fields are the type expected.</li>
<li>fields names/numbers are not used.</li>
<li>self describing types are not needed.</li>
<li>random access of data values is supported.</li>
</ul>

<p>Wire is designed to make it easy to convert from one wire format to another. 
  e.g. you can use fixed width binary data in memory for performance and variable width or text over the network.
  Different TCP connection could use different formats.</p>

<p>Wire also support hybrid wire formats.  e.g. you can have one format embedded in another.</p>

<h1>
<a id="support" class="anchor" href="#support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support</h1>

<p>This library will require Java 8. Support for C++ and C# planned.</p>

<h1>
<a id="text-formats" class="anchor" href="#text-formats" aria-hidden="true"><span class="octicon octicon-link"></span></a>Text Formats</h1>

<p>The text formats include</p>

<ul>
<li>YAML (a subset of mapping structures included)</li>
<li>JSON (planned)</li>
<li>XML (planned)</li>
<li>FIX (proposed)</li>
</ul>

<p>Options include</p>

<ul>
<li>field names (e.g. JSON) or field numbers (e.g. FIX)</li>
<li>optional fields with a default values can be dropped.</li>
<li>zero copy access to fields. (planned)</li>
<li>thread safe operations in text. (planned)</li>
</ul>

<p>To support wire format discovery, the first byte should be in the ASCII range,
    adding an ASCII whitespace if needed.</p>

<h1>
<a id="binary-formats" class="anchor" href="#binary-formats" aria-hidden="true"><span class="octicon octicon-link"></span></a>Binary Formats</h1>

<p>The binary formats include</p>

<ul>
<li>Binary YAML</li>
<li>typed data without fields.</li>
<li>raw untyped fieldless data</li>
<li>BSON (Binary JSon) (planned)</li>
</ul>

<p>Options for Binary format</p>

<ul>
<li>field names or field numbers</li>
<li>variable width</li>
<li>optional fields with a default value can be dropped.</li>
<li>fixed width data with zero copy support.</li>
<li>thread safe operations.</li>
</ul>

<p>Note: Wire supports debug/transparent combinations like self describing data with zero copy support.</p>

<p>To support wire format discovery, the first bytes should have the top bit set.</p>

<h1>
<a id="compression-options" class="anchor" href="#compression-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compression Options</h1>

<ul>
<li>no compression</li>
<li>Snappy compression (planned)</li>
<li>LZW compression (planned)</li>
</ul>

<h1>
<a id="bytes-options" class="anchor" href="#bytes-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bytes options</h1>

<p>Wire is built on top of the Bytes library, however Bytes in turn can wrap</p>

<ul>
<li>ByteBuffer - heap and direct</li>
<li>byte[] (via ByteBuffer)</li>
<li>raw memory addresses.</li>
</ul>

<h1>
<a id="uses" class="anchor" href="#uses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Uses</h1>

<p>Wire will be used for</p>

<ul>
<li>file headers</li>
<li>TCP connection headers where the optimal Wire format actually used can be negotiated.</li>
<li>message/excerpt contents.</li>
<li>the next version of Chronicle Queue</li>
<li>the API for marshalling generated data types.</li>
</ul>

<h1>
<a id="similar-projects" class="anchor" href="#similar-projects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Similar projects</h1>

<h2>
<a id="sbe" class="anchor" href="#sbe" aria-hidden="true"><span class="octicon octicon-link"></span></a>SBE</h2>

<p>Simple Binary Encoding is designed to do what it says.
    It's simple, it's binary and it supports C++ and Java.  It is 
    designed to be more efficient replacement for FIX. It is not limited to FIX 
    protocols and can be easily extended by updating an XML schema.</p>

<p>XML when it first started didn't use XML for it's own schema files, and it not
   insignificant that SBE doesn't use SBE for it's schema either.  This is because it is
   not trying to be human readable, it has XML which though standard isn't designed
   to be particularly human readable either.  Peter Lawrey thinks it's a limitation that it doesn't
   naturally lend itself to a human readable form.</p>

<p>The encoding SBE uses is similar to binary with field numbers and fixed width types.<br>
   SBE assumes the field types which can be more compact than Wire's most similar option 
   (though not as compact as others)</p>

<p>SBE has support for schema changes provided the type of a field doesn't change.</p>

<h2>
<a id="msgpack" class="anchor" href="#msgpack" aria-hidden="true"><span class="octicon octicon-link"></span></a>msgpack</h2>

<p>Message Pack is a packed binary wire format which also supports JSON for 
    human readability and compatibility. It has many similarities to the binary 
    (and JSON) formats of this library.  c.f. Wire is designed to be human readable first, 
    based on YAML, and has a range of options to make it more efficient, 
    the most extreme being fixed position binary.</p>

<p>Msgpack has support for embedded binary, whereas Wire has support for
    comments and hints to improve rendering for human consumption.</p>

<p>The documentation looks well thought out, and it is worth emulating.</p>

<h2>
<a id="comparison-with-capnproto" class="anchor" href="#comparison-with-capnproto" aria-hidden="true"><span class="octicon octicon-link"></span></a>Comparison with Cap'n'Proto</h2>

<table>
<thead>
<tr>
<th>Feature</th>
<th align="center">Wire Text</th>
<th align="center">Wire Binary</th>
<th align="center">Protobuf</th>
<th align="center">Cap'n Proto</th>
<th align="center">SBE</th>
<th align="center">FlatBuffers</th>
</tr>
</thead>
<tbody>
<tr>
<td>Schema evolution</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">caveats</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Zero-copy</td>
<td align="center">planned</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Random-access reads</td>
<td align="center">planned</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Random-access writes</td>
<td align="center">planned</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">?</td>
<td align="center">no</td>
<td align="center">?</td>
</tr>
<tr>
<td>Safe against malicious input</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">opt-in</td>
</tr>
<tr>
<td>Reflection / generic algorithms</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Initialization order</td>
<td align="center">any</td>
<td align="center">any</td>
<td align="center">any</td>
<td align="center">any</td>
<td align="center">preorder</td>
<td align="center">bottom-up</td>
</tr>
<tr>
<td>Unknown field retention</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td>Object-capability RPC system</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td>Schema language</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">custom</td>
<td align="center">custom</td>
<td align="center">XML</td>
<td align="center">custom</td>
</tr>
<tr>
<td>Usable as mutable state</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td>Padding takes space on wire?</td>
<td align="center">optional</td>
<td align="center">optional</td>
<td align="center">no</td>
<td align="center">optional</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Unset fields take space on wire?</td>
<td align="center">optional</td>
<td align="center">optional</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td>Pointers take space on wire?</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td>C++</td>
<td align="center">planned</td>
<td align="center">planned</td>
<td align="center">yes</td>
<td align="center">yes (C++11)*</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>Java</td>
<td align="center">Java 8</td>
<td align="center">Java 8</td>
<td align="center">yes</td>
<td align="center">yes*</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td>C#</td>
<td align="center">planned</td>
<td align="center">planned</td>
<td align="center">yes</td>
<td align="center">yes*</td>
<td align="center">yes</td>
<td align="center">yes*</td>
</tr>
<tr>
<td>Go</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
<td align="center">yes*</td>
</tr>
<tr>
<td>Other languages    lots!</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">6+</td>
<td align="center">others*</td>
<td align="center">no</td>
<td align="center">no</td>
</tr>
<tr>
<td>Authors' preferred use case</td>
<td align="center">distributed  computing</td>
<td align="center">financial / trading</td>
<td align="center">distributed  computing</td>
<td align="center">platforms /  sandboxing</td>
<td align="center">financial / trading</td>
<td align="center">games</td>
</tr>
</tbody>
</table>

<p>Based on <a href="https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html">https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html</a></p>

<p>Note: It not clear what padding which doesn't take up space on the wire means.</p>

<h1>
<a id="design-notes" class="anchor" href="#design-notes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design notes</h1>

<p>See <a href="https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html">https://capnproto.org/news/2014-06-17-capnproto-flatbuffers-sbe.html</a> for a comparison to other encoders.</p>

<h2>
<a id="schema-evolution" class="anchor" href="#schema-evolution" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schema evolution.</h2>

<p>Wire optionally supports;</p>

<ul>
<li>field name changes</li>
<li>field order changes.</li>
<li>capturing or ignoring unexpected fields.</li>
<li>setting of fields to the default if not available.</li>
<li>raw messages can be longer or short than expected.</li>
</ul>

<p>The more flexibility, the large the overhead in term of CPU and memory.<br>
WIre allows you to dynamically pick the optimal configuration and convert between these options.</p>

<h2>
<a id="zero-copy" class="anchor" href="#zero-copy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Zero copy</h2>

<p>Wire supports zero copy random access to fields and direct copy from in memory to the network.
It also support translation from one wire format to another e.g. switching between fixed length data and variable length data.</p>

<h2>
<a id="random-access" class="anchor" href="#random-access" aria-hidden="true"><span class="octicon octicon-link"></span></a>Random Access.</h2>

<p>You can access a random field in memory
   e.g. in 2 TB file, page in/pull into CPU cache, only the data relating to you read or write.</p>

<table>
<thead>
<tr>
<th>format</th>
<th>access style</th>
</tr>
</thead>
<tbody>
<tr>
<td>fixed length binary</td>
<td>random access without parsing first</td>
</tr>
<tr>
<td>variable length binary</td>
<td>random access with partial parsing. i.e. you can skip large portions</td>
</tr>
<tr>
<td>fixed length text</td>
<td>random access with parsing</td>
</tr>
<tr>
<td>variable length text</td>
<td>no random access</td>
</tr>
</tbody>
</table>

<p>Wire References are relative to the start of the data contained to allow loading in an arbitrary point in memory.</p>

<h2>
<a id="safe-against-malicious-input" class="anchor" href="#safe-against-malicious-input" aria-hidden="true"><span class="octicon octicon-link"></span></a>Safe against malicious input</h2>

<p>Wire has built in tiers of bounds checks to prevent accidental read/writing corrupting the data. 
   It is not complete enough for a security review.</p>

<h2>
<a id="reflection--generic-algorithms" class="anchor" href="#reflection--generic-algorithms" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reflection / generic algorithms</h2>

<p>Wire support generic reading and writing of an arbitrary stream. This can be used in combination with predetermined fields.
   e.g. you can read the fields you know about and asked it to provide the fields you didn't.
   You can also give generic field names like keys to a map as YAML does.</p>

<h2>
<a id="initialization-order" class="anchor" href="#initialization-order" aria-hidden="true"><span class="octicon octicon-link"></span></a>Initialization order</h2>

<p>Wire can handle unknown information like lengths by using padding.<br>
    It will go back and fill in any data which it wasn't aware of as it was writing the data.
    e.g. when it writes an object it doesn't know how long it is going to be so it add padding at the start.<br>
    Once the object has been written it goes back and overwrites the length. 
    It can also hand cases where the length was more than needed known as packing.</p>

<h2>
<a id="unknown-field-retention" class="anchor" href="#unknown-field-retention" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unknown field retention?</h2>

<p>Wire can handle reading data it didn't expect interspersed with data it did expect. 
   Rather than specify the expected field name, a StringBuilder is provided.</p>

<p>Note: there are times when you want to skip/copy an entire field or message without reading any more of it.  This is also supported.</p>

<h2>
<a id="object-maximumlimit-rpc-system" class="anchor" href="#object-maximumlimit-rpc-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Object-maximumLimit RPC system.</h2>

<p>Wire supports references based on a name, number or UUID.<br>
   This is useful when including a reference to an object the reader should lookup via another means.</p>

<p>A common case if when you have a proxy to a remote object and you want to pass or return this in an RPC call.</p>

<h2>
<a id="schema-language" class="anchor" href="#schema-language" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schema language</h2>

<p>Wire's schema is not externalised from the code, however it is planned to use YAML in a format it can parse.</p>

<h2>
<a id="usable-as-mutable-state" class="anchor" href="#usable-as-mutable-state" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usable as mutable state</h2>

<p>Wire supports storing an applications internal state. 
    This will not allow it to grow or shrink. You can't free any of it without copying 
    the pieces you need and discarding the original copy.</p>

<h2>
<a id="padding-takes-space-on-the-wire" class="anchor" href="#padding-takes-space-on-the-wire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Padding takes space on the wire.</h2>

<p>The Wire format chosen determines if there is any padding on the wire. 
    If you copy the in memory data directly it's format doesn't change. 
    If you want to drop padding you can copy the message to a wire format without padding.
    You can decide whether the original padding is to be preserved or not if turned back into a format with padding.</p>

<p>We could look at supporting Cap'n'Proto's zero byte removal compression.</p>

<h2>
<a id="unset-fields-take-space-on-the-wire" class="anchor" href="#unset-fields-take-space-on-the-wire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unset fields take space on the wire?</h2>

<p>Wire supports fields with and without optional fields and automatic means of removing them.<br>
    It doesn't support automatically adding them back in as information has been lost.</p>

<h2>
<a id="pointers-take-space-on-the-wire" class="anchor" href="#pointers-take-space-on-the-wire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Pointers take space on the wire.</h2>

<p>Wire doesn't have pointer but it does have content lengths which are 
   a useful hint for random access and robustness, but these are optional.</p>

<h2>
<a id="platform-support" class="anchor" href="#platform-support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Platform support</h2>

<p>Wire is Java 8 only for now.  Future version may support Java 6, C++ and C#</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Chronicle-wire maintained by <a href="https://github.com/OpenHFT">OpenHFT</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
